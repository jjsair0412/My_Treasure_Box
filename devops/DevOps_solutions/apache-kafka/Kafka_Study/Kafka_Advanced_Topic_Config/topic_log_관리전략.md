# topic log 관리전략
## 로그 정리 정책의 종류
로그 관리 정책은 크게 
- ```log.cleanup.policy=delete```  
- ```log.cleanup.policy=compact``` 

이 두가지가 있습니다.

둘중 어떤것을 선택할지는 사용자의 몫이며 , 상황에따라 다를 수 있습니다.


### ***log.cleanup.policy=delete***
데이터가 만들어진 시기에 따라 제거되는 것

- default 7일

kafka topic의 데이터는 , 기본적으로 일주일지나면 삭제됨

가장 흔한 두가지 옵션은 아래 ```log.retention.hours``` , ```log.retention.bytes``` 가 있음.
#### delete의 두가지 옵션
- ***log.retention.hours***
    - 데이터가 유지되는 시간. 
    - default : 168 시간 , 7일
    - 데이터를 더 오래유지할수록 더많은 디스크 씀
    - 데이터를 덜 유지할수록 디스크 많이 쓰지만 , 사용자 데이터 유실을 막을 수 있음
        - log.retention.ms, log.retention.minutes 둘 옵션을 같이 사용 가능
    >디스크는 싸기 때문에 , 그냥 늘려서 데이터를 오래유지하는것이 좋음
    >
    >-1 을 두어, 무제한으로 두는 경우도 있음

- ***log.retention.bytes***
    - 토픽에 있는 각 파티션의 최대 바이트 
    - default : -1 , 토픽공간이 무제한

### ***log.cleanup.policy=compact***
__consumer_offsets topic 내부 기본값

가장 최근에 발생한 키를 기준으로 , 메시지가 삭제됨.

#### 로그컴팩션을 유용하게 쓸 수 있는 상황
각 키의 최신 값을 가지고 , 어떤 토픽의 현재 상태에 대한 스냅샷을 요청할때 유용함.

이게 무슨말이냐면 ,

    어떤 key값은 유지되는데 , value값이 변동될 때 , 최신의 변동값만 갖고 싶을 때 유용하다는 말임

    예를들어서 , 연봉 정보가 Kafka에 들어간다 하자.

    key는 이름이고 , value가 연봉일 경우 , 

    철수, 1000
    영희, 2000
    미영, 5000

    으로 처음 세그먼트에 들어온다음 , 세그먼트가 닫히고 , 새로운 세그먼트가 생겻을 때, 철수와 미영이 승진해서 연봉이 올랏으면 , value만 바꼇을것이다.

    철수, 5000
    영희, 2000
    미영, 10000

    이럴때 , 과거의 연봉정보는 삭제해버리고 최신만 갖고있으면 되니 , 이럴때 로그컴팩션이 유용하다는소리다.

#### 로그컴팩션의 보장사항
로그컴팩션은 ***일부 메세지를 삭제해버리는데 , 순서를 재정렬하진 않습니다.***
- 오프셋이 삭제되서 없을 때 , 컨슈머는 이를 건너뛰어버린다.

로그컴팩션에 의해 삭제된 메세지는 ```delete.retention.ms``` 기간 동안 확인 가능
- 기본값 : 24시간

#### compact의 옵션들
- ***segment.ms***
    - 액티브 세그먼트를 닫기까지 기다리는 시간
    - default 7일

- ***segment.bytes***
    - 세그먼트 최대 크기
    - default : 1GB

- ***min.compaction.lag.ms***
    - 메시지가 컴팩트되기까지 기다리는 시간
    - default : 0

- ***min.retention.ms***
    - 컴팩션 되기로 한 데이터가 삭제되기까지의 시간
    - default : 24시간

- ***min.cleanable.dirty.ratio***
    - 수치를 높히면 정리 빈도는 낮아지고 효율성이 높아짐,

      수치를 낮추면 정리 빈도는 높아지고 효율성이 떨어짐.


## 로그 정리 진행주기
파티션 세그먼트가 생성될 때 마다 로그 정리가 실행됨.

>이말은 , 세그먼트가 자주 생성되면 , 로그 정리도 더 자주 발생.
>
>그렇다고 너무 자주하는건 별로임 , 로그정리는 CPU, 메모리를 소비하기 때문