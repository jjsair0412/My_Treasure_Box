# StatefulSet
## StatefulSet 이란 ?
스테이트풀셋은 애플리케이션의 스테이트풀을 관리하는데 사용하는 워크로드 API 오브젝트이다.

파드 집합의 디플로이먼트와 스케일링을 관리하며, 파드들의 순서 및 고유성을 보장한다 .

디플로이먼트와 유사하게, 스테이트풀셋은 동일한 컨테이너 스펙을 기반으로 둔 파드들을 관리한다. 디플로이먼트와는 다르게, 스테이트풀셋은 각 파드의 독자성을 유지한다. 이 파드들은 동일한 스팩으로 생성되었지만, 서로 교체는 불가능하다. 다시 말해, 각각은 재스케줄링 간에도 지속적으로 유지되는 식별자를 가진다.

스토리지 볼륨을 사용해서 워크로드에 지속성을 제공하려는 경우, 솔루션의 일부로 스테이트풀셋을 사용할 수 있다. 스테이트풀셋의 개별 파드는 장애에 취약하지만, 퍼시스턴트 파드 식별자는 기존 볼륨을 실패한 볼륨을 대체하는 새 파드에 더 쉽게 일치시킬 수 있다.

## 언제 사용하는가 ?
Application의 인스턴스가, 각각 안정적인 이름과 상태를 가지며 , 개별적으로 취급해야 하는 Application에 알맞게 만들어 졌습니다.
- 따라서 Redis, RDB 등의 Database를 Kubernetes에 구축한 뒤 각 파드를 클러스터링해야 할 때 사용하게 됩니다.

## StatefulSet vs ReplicaSet
ReplicaSet과 같은 오브젝트는 , 만약 레플리카셋이 관리하는 파드가 죽으면 완전히 새로운 이름, 상태, 네트워크 정보(ip 등) 을 가진 파드가 생성됩니다.
>이러한 Object들을 Stateless라 함

**그러나 StatefulSet은 , deployment처럼 pod template으로 파드를 관리하는데 , 만약 관리중인 파드가 죽으면, 교체되는 파드와 이전 파드는 모두
동일한 이름, 동일한 네트워크 아이덴티티, 상태 그대로 노드에서 되살아납니다.**

### StatefulSet과 persistentVolume and Claim
ReplicaSet과 같은 Stateless 오브젝트에서 생성된 파드는 , 모두 동일한 claim을 사용하고 같은 volume을 공유합니다.

**그러나, StatefulSet은 생성된 각 파드는 다른 피어와 구분되는 자체의 볼륨 세트(persistence volume, claim) 을 가집니다.**
>따라서 각 새로운 파드 인스턴스가 완전 무작위가 아니라, 예측 가능한(안정적인) 상태를 가지게 됩니다.

어찌됐건 StatefulSet은 동일한 파드 템플릿으로 파드가 생성되는데, 어떻게 각 파드가 따로따로 pv를 참조할까?
- 이에 대한 답은, **StatefulSet으로 생성된 파드는 pvc를 전부다 생성한다는것에 있다.**
    - 따라서 **스케일 업 하게되면, 그 수 만큼 pvc가 새로 생성된다.**
    - **데이터 상태를 보존하기 위해 Stateful pod가 제거되더라도 연결된 pvc는 제거되지 않는다.**
    - 이 말은, **스케일 다운을 시켜서 unmount 된 pvc가 있을 때 , 다시 스케일 업 한다면 남겨진 pvc로 mount된다는 의미 입니다.**

## 명명규칙
StatefulSet은 생성되는 파드가 예측이 가능합니다.
- 서수 인덱스(0부터 시작) 을 가지게 됩니다.
    - ex) 파드A-0, 파드A-1...

## ***거버닝 서비스***
StatefulSet은 각각의 파드가 독립적인 네트워크 아이덴티티를 가집니다.
>이게 무슨말이냐면, 만약 클러스터링된 ElasticSearch 3대가 있을 때, ElasticSearch는 Statefulset으로 관리되며 , 노드 파드는 3개일것 입니다.
>
>따라서, 각 ES 노드에 외부에서 접근할 수 있어야 하며, 해당 정보는 변화하면 안됩니다.

위와 같은 이유로 독립적 네트워크 아이덴티티를 가지는데, 이런것을 ***거버닝 헤드리스 서비스 (governing headless service)*** 를 생성해서 각 파드에 독립적 네트워크 아이덴티티를 제공합니다.

***거버닝 헤드리스 서비스*** 를 통해 각 파드는 자체적인 DNS 엔트리를 가지며, 다른 클라이언트가 독립적인 DNS 엔트리로 접근할 수 있습니다.
### 사용예시
만약 ***default n***s에 속하는 ***foo 라는 거버닝 서비스***가 있고 ***파드 이름이 A-0*** 이라면 , 아래와 같은 FQDN 을 통해 접근할 수 있습니다.
- Statefulset 파드 FQDN 주소
```bash
a-0.foo.default.svc.cluster.local
```

또한 거버닝 주소만 사용해서 , 모든 Statefulset의 이름을 찾아낼 수 도 있습니다.
- FQDN 주소
```bash
foo.default.svc.cluster.local
```

## StatefulSet의 scale up과 scale down
Statefulset은 scale up 하게 되면, 사용하지 않은 서수 인덱스를 가진 파드가 새로 생성됩니다.
- ex) 파드-0, 파드-1 **> 스케일 업 2개 증가 >** 파드-0, 파드-1, 파드-2, 파드-3

Statefulset을 scale down 시, **항상 어떤 인스턴스를 죽일지를 지정**할 수 있고, **어떤게 죽을지 예상**할 수 있다는 점이 장점
- Statefulset을 스케일 다운하면, 항상 서순이 가장 높은 (숫자가 높은) 파드를 먼저 제거합니다.
- 또한 스케일 다운시, Statefulset은 **항상 한 시점에 하나의 파드만 제거합니다.**
    - 그러한 이유는, 분산 데이터 저장 어플리케이션일 경우, 만약 3대 노드중 2대만 데이터를 갖고있었는데, 데이터가 저장된 2대를 동시에 제거해버리면 데이터가 유실되기 때문
    - 데이터를 복제할 시간을 Statefulset은 제공
- 위와 같은 이유로, **스케일 다운 시 인스턴스 하나라도 비정상일 경우 스케일 다운 작업을 허용 안함.**

## StatefulSet의 최대 하나의 의미 (at-most-one semantics)
StatefulSet은 동일한 아이덴티티를 갖기 때문에, kubernetes가 파드 상태를 확신할 수 없는 상황이라면 동일한 인스턴스가 동일한 아이덴티티로 실행될 수 있는 위험이 있습니다.

따라서 **Kubernetes의 StatefulSet은 , 교체 파드를 생성하기 전에, 파드가 더 이상 실행중이지 않는다는 점을 절대적으로 확신해야 하고, 확신이 들면 그때 파드를 생성해야 합니다.**
>이것이 최대 하나의 의미 (at-most-one semantics)