# kubernetes architecture
## ETCD
Kubernetes의 모든 메타데이터 및 클러스터 상태를 일관되게 유지시키기 위해, Key - value 형태의 저장소가 필요한데,. 그것이 ETCD 입니다.
- 저장되는 유일한 장소가 ETCD 이기 때문에, ETCD를 잘 관리해야 합니다.

Kubernetes API 서버만이 ETCD에 접근이 가능하며 , 다른 구성 요소는 ETCD에 접근하기 위해 API 서버를 거쳐야 합니다.

### 1. ETCD의 고 가용성 보장
ETCD 내부에 Kubernetes 모든 리소스 메타데이터 및 클러스터 상태가 저장되기에, 고가용성을 보장하기 위해 2대 이상의 ETCD 인스턴스를 실행합니다.

여러 ETCD 인스턴스가 존재한다 했을 때 , 각 인스턴스들은 서로 일관적이게 데이터가 유지되어야만 합니다.

따라서 ETCD 는 ***RAFT 합의 알고리즘*** 을 사용하여 어느 순간이던간에 각 노드 상태가 대다수 노드가 동의하는 상태이거나, 이전에 동의된 상태를 나타냅니다.

    RAFT 합의 알고리즘은 , 모든 ETCD 인스턴스들이 이전 상태에서 새로운 상태로 전환하기 위해 과반수가 찬성해야하는 알고리즘 입니다.

RAFT 합의 알고리즘을 사용하는 ETCD는 , ***과반수*** 라는 조건을 갖고있기 때문에 , 인스턴스 개수는 홀수로 유지시키는것이 에러 발생률을 낮출 수 있으며 , 대규모 ETCD 클러스터라 하더라도 5대 혹은 7대면 충분합니다.

## Kube API Server
클러스터 상태를 조회 및 변경하기 위해서, RESTful API로 CRUD 인터페이스를 제공하고, 상태를 ETCD에 저장하는 요소

Kubernetes API Server는, 아래와 같은 순서로 동작합니다.

### 1. 인증 플러그인으로 클라이언트 인증
API서버는 요청을 보낸 클라이언트를 인증하는데, HTTP 요청을 검사해 수행합니다.

### 2. 인가 플러그인을 통한 클라이언트 인가
인증된 사용자가 요청한 작업이, 요청한 리소스를 대상으로 수행할 수 있는지를 판별합니다.

### 3. 어드미션 컨트롤러 플러그인으로 요청된 리소스 확인 및 수정
리소스를 생성, 수정 삭제 요청인 경우, 해당 요청이 어드미션 컨트롤로 보내지게 됩니다.

어드미션 컨트롤 플러그인은 여러개를 사용하도록 설정되어 있으며, 종류는 다음과 같습니다.
- [어드미션 컨트롤러의 종류](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwaysadmit)

## 스케줄러
스케줄러는 할당된 노드가 없는 파드에게, 노드를 할당합니다.

그러나 스케줄러는 선택된 노드에 파드를 실행하도록 지시하지 않고, API 서버로 파드 정의를 갱신만 해줍니다.
API서버는 kubelet에 파드가 스케줄링된것을 통보하고, 해당 노드의 kubelet은 그걸 확인하자마자 파드의 컨테이너를 생성하고 실행하게 됩니다.

스케줄러는 기본적으로 기본 스케줄링 알고리즘을 따릅니다.
### 1. 기본 스케줄링 알고리즘
기본 스케줄링 알고리즘에서, 노드선택 기준은 다음과 같습니다.
- 1. 모든 노드 중 파드를 스케줄링 할 수 있는 노드목록을 필터링
- 2. 수용 가능한 노드의 우선순위를 정한 뒤, 점수가 높은 노드를 선택합니다. 만약 여러 노드가 최상위 점수를 갖고잇다면, 라운드로빈 방식으로 파드를 분배합니다.

### 2. Multi Scheduler
Kubernetes에서는 기본적으로 생성하는 스케줄러 외에 여러개의 스케줄러를 실행할 수 있습니다.

따라서 사용자가 직접 스케줄러를 커스텀해서 사용하거나, 기본 스케줄러를 사용하거나 할 수 있습니다.

## 컨트롤러
API 서버는 리소스를 etcd에 저장하고, 변경사항을 통보하는것 외에는 하지 않습니다. 그리고 스케줄러는 파드에 노드만 할당합니다.

그러므로 API서버로 배포된 리소스에 대해, 지정된 대로 시스템을 원하는 상태로 변경할 수 있게끔 하는 다른 구성요소가 필요한데, 이를 **컨트롤러**가 합니다.

컨트롤러는 API 서버에서 리소스(디플로이먼트,서비스,엔드포인트,노드 등..) 가 변경되는것을 감시하고, 각 변경 작업(새로운 오브젝트 생성 및 변경, 삭제)을 수행합니다. 

컨트롤러는 실제 상태를 원하는 상태(리소스의 spec 섹션에 정의) 로 조정하고, 새로운 상태를 리소스의 status 섹션에 기록합니다.

### 1. 컨트롤러의 종류
컨트롤러는 다양한종류가 있는데, Kubernetes에서 생성 가능한 거의모든 리소스에 대해 컨트롤러가 있는것을 확인할 수 있습니다.

- 레플리카셋, 데몬셋, 잡 컨트롤러
- 디플로이먼트 컨트롤러
- 노드 컨트롤러
- 서비스 컨트롤러
...등

### 2. 주의할 점
컨트롤러는 파드의 변동사항에 대해 파드 메니페스트를 변경하고 해당 사항을 API서버에게 일러줄 뿐이지, 실제로 파드를 스케줄링하고 동작시키는건, 스케줄러 와 kubelet이 파드 스케줄링과 컨테이너 실행 작업을 수행합니다.

## Kubelet
kubelet은 간단히 말해, 워커노드에서 실행하는 모든것을 담당하는 구성 요소입니다.

kubelet이 실행중인 노드를 리소스로 만들어 API서버에 등록한 다음, API 서버를 지속적으로 모니터링하다가 해당 노드에 파드가 스케줄링되면, 파드의 컨테이너를 실행합니다.
설정된 컨테이너 런타임(docker, cri-o, containerd) 에 지정된 컨테이너 이미지로 컨테이너를 실행하도록 지시함으로써 해당 작업을 수행합니다.

### 1. ETC - API 서버 없이 static pod 수행
Kubelet은 노드의 로컬 디렉토리에 존재하는 파드 매니페스트 파일을 기반으로 파드를 실행할 수도 있습니다.

시스템 구성요소 파드 매니페스트를, kubelet 매니페스트 디렉터리 안에 넣어서 kubelet이 실행하고 관리하게할 수 있습니다.
정적파드는 파드만생성 가능하고, 컨트롤러가 관리하는 리소스인 레플리카셋 등은 생성이 불가능합니다.

### 2. 정적 파드 Lfie-Cycle
- 생성 : 정적 파드 경로에 yaml 파일이 존재할 경우 자동으로 파드 생성
- 유지 : 정적 파드 경로에 yaml 파일이 존재할 경우 파드가 삭제되어도 재생성
- 수정 : 정적 파드 경로의 yaml 파일을 수정하면 자동으로 기존 파드가 삭제되고 새로운 파드가 생성
- 삭제 : 정적 파드 경로의 yaml 파일을 삭제하고, 파드를 delete해야 완전 삭제

### 3. 정적 파드 생성 디렉터리
```/var/lib/kubelet/config.yaml```에서 ```staticPodPath```를 보면 확인할 수 있습니다.

그리고 해당 디렉터리에 파드 yaml을 생성하면 정적 파드가 생성됩니다.

## Kubernetes Service Proxy - Kube Proxy
클라이언트가 쿠버네티스 파드에 접근할 때 필요한 네트워크 프록시 및 로드벨런싱을 제공합니다.

Kube-proxy의 로드벨런싱 작동 방식은, ```ser-space mode(거의 사용되지 않음)```, ```IPtables mode```, 그리고 ```IPVS mode``` 가 있습니다.
- 관련 글은 다른문서에 자세히 작성해둘 예정

기본적으로 Kubernetes의 Kube-Proxy는 ```IPtables mode``` 를 기반으로 작동하기 때문에, 로드 벨런싱이 라운드 로빈방식처럼 균등하게 작동하지 않습니다. 그 이유는 ```IPtables mode``` 는 로드 밸런싱 알고리즘을 지원하지 않고, 파드를 무작위로 선택하기 때문입니다.